Description: Changes src.mailman.utilities.filesystem:makedirs behaviour
 A bug in mailman.utilities.filesystem:makedirs was spotted when logrotate
 complained regarding /var/log/mailman3 permissions, which were 2775. This is
 due to this function updating the mailman3 directories paths ACLs at each
 startup. As this behaviour blocks the end user to update the ACLs of the
 directory and the default permission was some kind of remaining behaviour from
 mailman 2, this patch has been submitted to upstream, and is here in the mean
 time to allow a proper behaviour.
Author: Pierre-Elliott Bécue <becue@crans.org>
Bug: https://gitlab.com/mailman/mailman/issues/439
Bug-Debian: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=883464
Last-Update: 2017-12-05
From: Pierre-Elliott Bécue <becue@crans.org>
Date: Mon, 4 Dec 2017 15:15:50 +0100
Subject: _change_mkdirs_behaviour

---
 src/mailman/utilities/filesystem.py | 39 ++++++++++++++++++++++++++++++++-----
 1 file changed, 34 insertions(+), 5 deletions(-)

diff --git a/src/mailman/utilities/filesystem.py b/src/mailman/utilities/filesystem.py
index 19862ab..fc711b7 100644
--- a/src/mailman/utilities/filesystem.py
+++ b/src/mailman/utilities/filesystem.py
@@ -43,7 +43,7 @@ class umask:
 
 
 @public
-def makedirs(path, mode=0o2775):
+def makedirs(path, mode=0o0755):
     """Create a directory hierarchy, ensuring permissions.
 
     Other than just calling os.makedirs(), this ensures that the umask is
@@ -54,13 +54,22 @@ def makedirs(path, mode=0o2775):
     :param mode: The numeric permission mode to use.
     :type mode: int
     """
-    with suppress(FileExistsError):
-        with umask(0):
-            os.makedirs(path, mode)
+    with umask(0):
+        # In order for os.walk to set permissions appropriately if required,
+        # the FIRST NON EXISTENT parent directory of the one we wanted to
+        # create has to be provided.
+        upwards = first_inexistent_directory(path)
+
+        # The directory exists, nothing to do.
+        if upwards is None:
+            return
+
+        os.makedirs(path, mode)
+
     # Some systems such as FreeBSD ignore mkdir's mode, so walk the just
     # created directories and try to set the mode, ignoring any OSErrors that
     # occur here.
-    for dirpath, dirnames, filenames in os.walk(path):
+    for dirpath, _, _ in os.walk(upwards):
         with suppress(OSError):
             os.chmod(dirpath, mode)
 
@@ -69,3 +78,23 @@ def makedirs(path, mode=0o2775):
 def safe_remove(path):
     with suppress(FileNotFoundError):
         os.remove(path)
+
+
+def first_inexistent_directory(path):
+    """Splits iteratively a path until it gives the first non-existent directory in the tree.
+
+    That is, if /home/user/foo/bar/baz is given to the function, and /home/user/foo/bar
+    doesn't exist but /home/user/foo exists, returns /home/user/foo/bar.
+    """
+    directory = path
+    rhs = None
+
+    while True:
+        if os.path.isdir(directory):
+            if rhs is None:
+                return None
+            else:
+                return os.path.join(directory, rhs)
+        elif os.path.exists(directory):
+            raise FileExistsError("The path %s exists but is not a directory.", directory)
+        directory, rhs = os.path.split(directory)
